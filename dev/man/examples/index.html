<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Workflow · TriangleMesh.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../"><img class="logo" src="../../assets/logo.svg" alt="TriangleMesh.jl logo"/></a><h1>TriangleMesh.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li class="current"><a class="toctext" href>Workflow</a><ul class="internal"><li><a class="toctext" href="#Create-a-Polygon-1">Create a Polygon</a></li><li><a class="toctext" href="#Standard-Polygons-1">Standard Polygons</a></li><li><a class="toctext" href="#Meshing-a-Polygon-1">Meshing a Polygon</a></li><li><a class="toctext" href="#Meshing-a-Point-Cloud-1">Meshing a Point Cloud</a></li><li><a class="toctext" href="#Using-Triangle&#39;s-switches-1">Using Triangle&#39;s switches</a></li><li><a class="toctext" href="#Refining-a-Mesh-1">Refining a Mesh</a></li><li><a class="toctext" href="#Visualization-1">Visualization</a></li></ul></li><li><a class="toctext" href="../mtm/">Modules, Types and Methods</a></li><li><a class="toctext" href="../mtm_idx/">Index</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Workflow</a></li></ul><a class="edit-page" href="https://github.com/konsim83/TriangleMesh.jl/blob/master/docs/src/man/examples.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Workflow</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Workflow-1" href="#Workflow-1">Workflow</a></h1><p>This section is intended to give you an idea of how to use <code>TriangleMesh</code>. The workflow is actually very simple and we demonstrate it here using a few simple examples. </p><h2><a class="nav-anchor" id="Create-a-Polygon-1" href="#Create-a-Polygon-1">Create a Polygon</a></h2><p><em>Create a polygon to be meshed manually.</em></p><p>First we need to create a polygon - a planar straight-line graph (PSLG) - that describes a bounded area in the plane. A PSLG consists of nodes and (optional) segments. Each node can (but does not need to) have a marker indicating that it belongs to a certain set and a number of real attributes. Each segment can have a marker as well. If the set of segments (and the set of segment markers) is empty the polygon is simply a set of unconnected points.</p><p>We will create a polygon that describes a rhombus with a squared hole in the middle from the node set</p><pre><code class="language-julia"># size is number_points x 2
node = [1.0 0.0 ; 0.0 1.0 ; -1.0 0.0 ; 0.0 -1.0 ;
        0.25 0.25 ; -0.25 0.25 ; -0.25 -0.25 ; 0.25 -0.25] </code></pre><p>and the segments</p><pre><code class="language-julia"># size is number_segments x 2
seg = [1 2 ; 2 3 ; 3 4 ; 4 1 ; 5 6 ; 6 7 ; 7 8 ; 8 5] </code></pre><p>We now have two boundaries - an inner and an outer. We will also give each point and each segment a marker according to the boundary</p><pre><code class="language-julia"># all points get marker 1
node_marker = [ones(Int,4,1) ; 2*ones(Int,4,1)]
# last segment gets a different marker
seg_marker = [ones(Int,4) ; 2*ones(Int,4)]</code></pre><p>as well as 2 random attributes for each point</p><pre><code class="language-julia"># size is number_points x number_attr
node_attr = rand(8,2) </code></pre><p>We now have to specify that the segemnts 5<span>$\rightarrow$</span>6, 6<span>$\rightarrow$</span>7, 7<span>$\rightarrow$</span>8 and 8<span>$\rightarrow$</span>5 enclose a hole. This is done by providing a point that is in the interior of the hole:</p><pre><code class="language-julia"># size is number_holes x 2
hole = [0.5 0.5] </code></pre><div class="admonition tip"><div class="admonition-title">Tip</div><div class="admonition-text"><ul><li>Not every point provided for a PSLG needs to be part of a segment.</li><li>Segemnts will be present in the triangular mesh (although they might be subdivided)</li><li>Do not place holes on a segment. They must be enclosed by segments.</li></ul></div></div><p>The first step is to set up a <a href="../mtm/#TriangleMesh.Polygon_pslg"><code>Polygon_pslg</code></a> struct that holds the polygon data:</p><pre><code class="language-julia">poly = Polygon_pslg(8, 1, 2, 8, 1)</code></pre><p>Now we have to pass nodes, segments and markers etc. manually:</p><pre><code class="language-julia">set_polygon_point!(poly, node)
set_polygon_point_marker!(poly, node_marker)
set_polygon_point_attribute!(poly, node_attr)
set_polygon_segment!(poly, seg)
set_polygon_segment_marker!(poly, seg_marker)
set_polygon_hole!(poly, hole)</code></pre><p>Now the polygon is created!</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Segment markers are set to one by default.</p></div></div><h2><a class="nav-anchor" id="Standard-Polygons-1" href="#Standard-Polygons-1">Standard Polygons</a></h2><p><em>Create a standard polygon from convenience methods.</em></p><p><code>TriangleMesh</code> provides some standard polygons through convenience methods that are often used. Their code can of course be copied out and customized accoring to your needs (different markers, attributes etc.)</p><ul><li><a href="../mtm/#TriangleMesh.polygon_unitSimplex-Tuple{}"><code>polygon_unitSimplex</code></a> creates a polygon desribing a unit simplex</li><li><a href="../mtm/#TriangleMesh.polygon_unitSquare-Tuple{}"><code>polygon_unitSquare</code></a> creates a polygon desribing the unit square <span>$[0,1]\times[0,1]$</span></li><li><a href="../mtm/#TriangleMesh.polygon_unitSquareWithHole-Tuple{}"><code>polygon_unitSquareWithHole</code></a> creates a polygon desribing the unit square with a hole <span>$[0,1]\times[0,1]\setminus [1/4,3/4]\times[1/4,3/4]$</span></li><li><a href="../mtm/#TriangleMesh.polygon_regular-Tuple{Int64}"><code>polygon_regular</code></a> creates a polygon regular polyhedron whose corner points are one the unit circle</li><li><a href="../mtm/#TriangleMesh.polygon_Lshape-Tuple{}"><code>polygon_Lshape</code></a> creates a polygon desribing an L-shaped domain</li><li><a href="../mtm/#TriangleMesh.polygon_struct_from_points-Tuple{Array{Float64,2},Array{Int64,2},Array{Float64,2}}"><code>polygon_struct_from_points</code></a> creates a polygon struct without segments (needed only internally, usually not necessary to use)</li></ul><h2><a class="nav-anchor" id="Meshing-a-Polygon-1" href="#Meshing-a-Polygon-1">Meshing a Polygon</a></h2><p><em>Convenience method for polygons.</em></p><p>Here we show how to create a mesh from a PSLG using a convenience method. To demonstrate this we create a mesh of an L-shaped domain. It is actually a fairly simple procedure.</p><p>First we create an L-shaped domain using one of the above methods to construct standard polygons:</p><pre><code class="language-julia">poly = polygon_Lshape()</code></pre><p>Then we create the mesh by calling <code>create_mesh</code> with <code>poly</code> as its first argument. The rest of the arguments is optional but usually necessary to adust the behavior of the meshing algorithm according to your needs. An example could be:</p><pre><code class="language-julia">mesh = create_mesh(poly, info_str=&quot;my mesh&quot;, voronoi=true, delaunay=true, set_area_max=true)</code></pre><p>The argument <code>set_area_max=true</code> will make Julia ask the user for a maximum area of triangles in the mesh. Provide a reasonable input and the mesh will be created. For details of what the optional arguments are see <a href="../mtm/#TriangleMesh.create_mesh-Tuple{Array{Float64,2},String}"><code>create_mesh</code></a>.</p><h2><a class="nav-anchor" id="Meshing-a-Point-Cloud-1" href="#Meshing-a-Point-Cloud-1">Meshing a Point Cloud</a></h2><p><em>Convenience method for point clouds.</em></p><p>Meshing a point cloud with <code>TriangleMesh</code> is easy. As an example we will create mesh of the convex hull of a number of random points and tell the algorithm that it is not allowed to add more points to it (which could be done though to improve the mesh quality).</p><p>Let&#39;s create a point cloud:</p><pre><code class="language-julia">p = rand(10,2)</code></pre><p>And now the mesh:</p><pre><code class="language-julia">mesh = create_mesh(p, info_str=&quot;my mesh&quot;, prevent_steiner_points=true)</code></pre><p>For details of what the optional arguments are see <a href="../mtm/#TriangleMesh.create_mesh-Tuple{Array{Float64,2},String}"><code>create_mesh</code></a>.</p><h2><a class="nav-anchor" id="Using-Triangle&#39;s-switches-1" href="#Using-Triangle&#39;s-switches-1">Using Triangle&#39;s switches</a></h2><p><em>Direct passing of command line switches.</em></p><p>If you are familiar with the Triangle library then <code>TriangleMesh</code> leaves you the option to pass Triangle&#39;s command line switches to the meshing algorithm directly. </p><p>As an example we create a mesh of the unit square with a squared hole in its middle</p><pre><code class="language-julia">poly = polygon_Lshape()</code></pre><p>The define the switches:</p><pre><code class="language-julia">switches = &quot;penvVa0.01D&quot;</code></pre><p>The <code>p</code> switch tells Triangle to read a polygon, <code>e</code> outputs the edges, <code>n</code> the cell neighbors, <code>v</code> a Voronoi diagram and so on. For details see the <a href="https://www.cs.cmu.edu/~quake/triangle.html">documentation of Triangle</a>. Now create the mesh with the command</p><pre><code class="language-julia">mesh = create_mesh(poly, switches)</code></pre><p>Similarly to this one can create a mesh of a point cloud.</p><h2><a class="nav-anchor" id="Refining-a-Mesh-1" href="#Refining-a-Mesh-1">Refining a Mesh</a></h2><p><em>Refine an existing mesh.</em></p><p>Mesh refinement can, for example, be necessary to improve the quality of a finite element solution. <code>TriangleMesh</code> offers methods to refine a mesh. </p><p>Suppose an a-posteriori error estimator suggested to refine the triangles with the indices 1, 4, 9 of our mesh. Suppose also we would like to keep the edges of the original mesh (but we allow subdivision). No triangle in the new mesh that is a subtriangle of the ones to be refined should have an area larger than 1/10 of the &quot;parent&quot; triangle.</p><p>We use the convenience method for doing this refinement:</p><pre><code class="language-julia">mesh_refined = refine(mesh, ind_cell=[1;4;9], divide_cell_into=10, keep_edges=true)</code></pre><p>We could also pass Triangle&#39;s command line switches. Suppose we would like to refine the entire mesh and only keep segments (not edges). No triangle should have a larger area than 0.0001. This can be done, for example by:</p><pre><code class="language-julia">switches = &quot;rpenva0.0001q&quot;
mesh_refined = refine(mesh, switches)</code></pre><p>The <code>r</code> switch stands for refinement. For proper use of the switches we again refer to <a href="https://www.cs.cmu.edu/~quake/triangle.html">Triangle</a>.</p><p><code>TriangleMesh</code> also offers a simple method to divide a list of triangle into 4 triangles. This will create for each triangle to be refined 4 similar triangles and will hence preserve the Delaunay property of a mesh.</p><pre><code class="language-julia">mesh_refined = refine_rg(mesh, ind_cell=[1;4;9])</code></pre><p>Omitting the second argument will simply refine the entire mesh. </p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The <a href="../mtm/#TriangleMesh.refine_rg-Tuple{TriMesh,Array{Int64,1}}"><code>refine_rg</code></a> method is very slow for large meshes (&gt;100000 triangles) and should be avoided. For smaller meshes it can be used though to create a simple hierarchy of meshes which can be advantegeous if one wants to compare numerical solutions on sucessively refined meshes.</p></div></div><h2><a class="nav-anchor" id="Visualization-1" href="#Visualization-1">Visualization</a></h2><p>There are of course many ways to visualize a triangular mesh. A very simple way is to run this script:</p><pre><code class="language-julia">using TriangleMesh, PyPlot

function plot_TriMesh(m :: TriMesh; 
                        linewidth :: Real = 1, 
                        marker :: String = &quot;None&quot;,
                        markersize :: Real = 10,
                        linestyle :: String = &quot;-&quot;,
                        color :: String = &quot;red&quot;)

    fig = matplotlib[:pyplot][:figure](&quot;2D Mesh Plot&quot;, figsize = (10,10))
    
    ax = matplotlib[:pyplot][:axes]()
    ax[:set_aspect](&quot;equal&quot;)
    
    # Connectivity list -1 for Python
    tri = ax[:triplot](m.point[1,:], m.point[2,:], m.cell&#39;.-1 )
    setp(tri,   linestyle = linestyle,
                linewidth = linewidth,
                marker = marker,
                markersize = markersize,
                color = color)
    
    fig[:canvas][:draw]()
    
    return fig
end</code></pre><p>Note that you need to have the <code>PyPlot</code> package (well... actually only the <code>PyCall</code> package and Python&#39;s <code>matplotlib</code>) installed. Now you can call the function <code>plot_TriMesh</code> and you should see the mesh in a figure window. This file can also be found in the examples folder on GitHub.</p><footer><hr/><a class="previous" href="../../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../mtm/"><span class="direction">Next</span><span class="title">Modules, Types and Methods</span></a></footer></article></body></html>
